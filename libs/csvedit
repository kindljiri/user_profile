#! /bin/sh

#Library to work with csv files
#This Library below contains its own documentation just do:
#grep "#DOC: " csvedit| sed 's/[ \t]*#DOC://'

# Library of functions to manipulate ini files
#Variables:
csveditAuthor='Jiri Kindl'
csveditVersion='20250626'

#Version history at the end of the file:

#DOC: LIBRARY NAME: csvedit
#DOC: DESCRIPTION: Library to work with csv files  
#DOC: 

#DOC: getCsveditVersion
#DOC:   NAME 
#DOC:     getCsveditVersion - Print csvedit version 
#DOC:   SYNOPSIS 
#DOC:     getCsveditVersion
#DOC:   DESCRIPTION 
#DOC:     Print csvedit version, the version number is last changed date in format YYYYMMDD.
#DOC: 
getCsveditVersion() {
  echo $csveditVersion
  return 0
}

#DOC: csvRemoveTrailingCommas [-i] [FILE]
#DOC:   NAME
#DOC:        csvRemoveTrailingCommas - removes trailing commas at the end of each line
#DOC:   SYNOPSIS
#DOC:        csvRemoveTrailingCommas [-i] [FILE]
#DOC:   DESCRIPTION
#DOC:        Removes commas at the end of each line in a CSV file or from standard input.
#DOC:        If FILE is provided, it reads from the file; otherwise, it reads from stdin.
#DOC:        The -i option modifies the file in place instead of printing output.
#DOC:   EXAMPLE
#DOC:        csvRemoveTrailingCommas myCsvFile.csv
#DOC:        csvRemoveTrailingCommas -i myCsvFile.csv
#DOC:        cat myCsvFile.csv | csvRemoveTrailingCommas
#DOC: 
csvRemoveTrailingCommas() {
  local inplace=0
  local filename=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -i) inplace=1 ;;
      *) filename="$1" ;;
    esac
    shift
  done

  if [ -n "$filename" ]; then
    csvCheckFile "$filename"
    local checkFileResult=$?
    if [ $checkFileResult -ne 0 ]; then
      echo "Usage: csvRemoveTrailingCommas [-i] [FILE]" >&2
      return $checkFileResult
    fi

    if [ $inplace -eq 1 ]; then
      sed -i 's/\r$//' "$filename" && sed -i 's/,*$//' "$filename"
    else
      sed 's/\r$//' "$filename" |sed 's/,*$//'
    fi
  else
    sed 's/\r$//'|sed 's/,*$//'
  fi
}

#DOC: csvCheckFile FILE
#DOC:   NAME
#DOC:        csvCheckFile - check if a file exists and is readable
#DOC:   SYNOPSIS
#DOC:        csvCheckFile FILE
#DOC:   DESCRIPTION
#DOC:        csvCheckFile checks if the FILE given as an argument exists and is readable. If the file does not exist or is not readable, the function will return an error message and a non-zero exit code.
#DOC:   EXIT STATUS
#DOC:        0 if the file exists and is readable
#DOC:        11 if the file does not exist
#DOC:        12 if the file is not readable
#DOC: 
csvCheckFile() {
  local filename=$1
  if [ ! -e $filename ]
  then
    echo "Error: File $filename do not exist" >&2
    return 11
  fi

  if [ ! -r $filename ]
  then
    echo "Error: File $filename not readable, Permission Denied" >&2
    return 12
  fi
  return 0
}

#DOC: csvGetNumberOfFields [FILE]
#DOC:   NAME
#DOC:        csvGetNumberOfFields - count the number of fields in a CSV row
#DOC:   SYNOPSIS
#DOC:        csvGetNumberOfFields [FILE]
#DOC:   DESCRIPTION
#DOC:        csvGetNumberOfFields counts the number of fields in each row of a CSV file or standard input.
#DOC:        If FILE is provided, it reads from the file; otherwise, it reads from stdin.
#DOC:   EXAMPLE
#DOC:        csvGetNumberOfFields myCsvFile.csv
#DOC:        cat myCsvFile.csv | csvGetNumberOfFields
#DOC: 
csvGetNumberOfFields() {
  local filename=$1

  if [ -n "$filename" ]; then
    csvCheckFile "$filename"
    local checkFileResult=$?
    if [ $checkFileResult -ne 0 ]; then
      echo "Usage: csvGetNumberOfFields [FILE]" >&2
      return $checkFileResult
    fi
    input=$(cat "$filename")
  else
    input=$(cat)
  fi

  echo "$input" | sed 's/\\"//g' | tr -cd '\n",' | sed 's/",*"//g' | while read -r row; do
    echo "$row" | wc -c
  done
}

#DOC: csvCheckUniformFieldCount [FILE]
#DOC:   NAME
#DOC:        csvCheckUniformFieldCount - verify all rows in a CSV file have the same number of fields
#DOC:   SYNOPSIS
#DOC:        csvCheckUniformFieldCount [FILE]
#DOC:   DESCRIPTION
#DOC:        Returns 0 if all rows in the CSV have the same number of fields. Non-zero otherwise.
#DOC:        If FILE is provided, reads from the file; otherwise, reads from stdin.
#DOC:   EXAMPLE
#DOC:        csvCheckUniformFieldCount myCsvFile.csv
#DOC:        cat myCsvFile.csv | csvCheckUniformFieldCount
#DOC: 
csvCheckUniformFieldCount() {
  local file="$1"
  local input

  if [[ -n "$file" ]]; then
    if [[ ! -f "$file" || ! -r "$file" ]]; then
      echo "File '$file' not found or not readable." >&2
      return 1
    fi
    input=$(cat "$file")
  else
    input=$(cat)
  fi

  local unique_fields
  unique_fields=$(echo "$input" | csvGetNumberOfFields | sort -nu | wc -l)

  if [[ "$unique_fields" -eq 1 ]]; then
    return 0
  else
    echo "Non-uniform number of fields detected." >&2
    return 2
  fi
}


#DOC: csvGetHeader FILE
#DOC:   NAME
#DOC:        csvGetHeader - print out the header (first line) of a file
#DOC:   SYNOPSIS
#DOC:        csvGetHeader FILE
#DOC:   DESCRIPTION
#DOC:        csvGetHeader prints out the header (first line) of the FILE given as an argument. If the file does not exist or is not readable, the function will return an error message and a non-zero exit code.
#DOC:   EXIT STATUS
#DOC:        0 if the header is successfully printed
#DOC:        11 if the file does not exist
#DOC:        12 if the file is not readable
#DOC: 
csvGetHeader() {
  local filename=$1
  csvCheckFile $filename
  local checkFileResult=$?
  if [ $checkFileResult -ne 0 ]
  then
    echo "Usage: csvGetHeader FILE" >&2
    return $checkFileResult
  fi
  head -n 1 $filename
  return 0
}

#DOC: csvGetContent FILE
#DOC:   NAME
#DOC:        csvGetContent - print out the content of a file without the header (first line)
#DOC:   SYNOPSIS
#DOC:        csvGetContent FILE
#DOC:   DESCRIPTION
#DOC:        csvGetContent prints out the content of the FILE given as an argument without the header (first line). If the file does not exist or is not readable, the function will return an error message and a non-zero exit code.
#DOC:   EXIT STATUS
#DOC:        0 if the content is successfully printed
#DOC:        11 if the file does not exist
#DOC:        12 if the file is not readable
#DOC: 
csvGetContent() {
  local filename=$1
  csvCheckFile $filename
  local checkFileResult=$?
  if [ $checkFileResult -ne 0 ]
  then
    echo "Usage: csvGetContent FILE" >&2
    return $checkFileResult
  fi
  sed '1 d' $filename
  return 0
}

#DOC: csvContainsUnbalancedQuotes [-v] FILE
#DOC:   NAME
#DOC:        csvContainsUnbalancedQuotes - check if a CSV file contains unbalanced quotes
#DOC:   SYNOPSIS
#DOC:        csvContainsUnbalancedQuotes [-v] FILE
#DOC:   DESCRIPTION
#DOC:        csvContainsUnbalancedQuotes checks if a CSV file contains unbalanced quotes.
#DOC:        Optional switches:
#DOC:        -v for verbose output, which tells which lines contain unbalanced quotes
#DOC:   EXAMPLE
#DOC:        csvContainsUnbalancedQuotes myCsvFile.csv
#DOC:        csvContainsUnbalancedQuotes -v myCsvFile.csv
#DOC:   EXIT STATUS
#DOC:        0 if the file contains balanced quotes
#DOC:        1 if the file contains unbalanced quotes
#DOC:        2 if there are argument errors
#DOC:        3 if there are file-related errors
csvContainsUnbalancedQuotes() {
  local verbose=0
  local filename

  # Process arguments
  while [ "$1" != "" ]; do
    case $1 in
      -v | --verbose )
        verbose=1
        ;;
      --help )
        echo "Usage: csvContainsUnbalancedQuotes [-v] FILE" >&2
        exit 0
        ;;
      * )
        if [ -z "$filename" ]; then
          filename=$1
        else
          echo "Usage: csvContainsUnbalancedQuotes [-v] FILE" >&2
          return 2  # Argument error
        fi
    esac
    shift
  done

  if [ -z "$filename" ]; then
    echo "Usage: csvContainsUnbalancedQuotes [-v] FILE" >&2
    return 2  # Argument error
  fi

  if [ ! -f "$filename" ]; then
    [ $verbose -eq 1 ] && echo "File not found!" >&2
    return 3  # File error
  fi
  if [ ! -r "$filename" ]; then
    [ $verbose -eq 1 ] && echo "File is not readable!" >&2
    return 3  # File error
  fi

  local line_number=0
  local unbalanced=0

  while IFS= read -r line || [ -n "$line" ]; do
    line_number=$((line_number + 1))
    local cleaned_line=$(echo "$line" | tr -c '\\,"' ' ' | sed 's/\\\"/  /g')
    local qc=$(echo "$cleaned_line" | fold -w1 | grep -o '"' | wc -l)
    if [ $(expr $qc % 2) -ne 0 ]; then
      unbalanced=1
      [ $verbose -eq 1 ] && echo "Unbalanced quotes in line $line_number: $line" >&2
    fi
  done < "$filename"

  return $unbalanced
}

#DOC: csvLine2Fields [-n] LINE
#DOC:   NAME
#DOC:        csvLine2Fields - split a CSV line into individual fields, with each field on a new line
#DOC:   SYNOPSIS
#DOC:        csvLine2Fields [-n] LINE
#DOC:   DESCRIPTION
#DOC:        csvLine2Fields processes a single CSV line, handles quoted fields, and prints each field on a new line.
#DOC:        Optional switches:
#DOC:        -n to prepend each field with its number
#DOC:   EXAMPLE
#DOC:        line='Smith, "123 Elm St., Springfield", 35, "Life is \"what\" happens, when you''re busy making other plans.", Enjoys "coding, hiking", and "reading"'
#DOC:        csvLine2Fields "$line"
#DOC:        csvLine2Fields -n "$line"
#DOC:   EXIT STATUS
#DOC:        0 if the line is successfully processed and fields are printed
#DOC:        1 if there are argument errors
csvLine2Fields() {
  local numbered=0
  local csvline=''

  # Process arguments
  while [ "$1" != "" ]; do
    case $1 in
      -n )
        numbered=1
        ;;
      --help )
        echo "Usage: csvLine2Fields [-n] LINE" >&2
        exit 0
        ;;
      * )
        if [ -z "$csvline" ]; then
          csvline="$1"
        else
          echo "Usage: csvLine2Fields [-n] LINE" >&2
          return 1  # Argument error
        fi
    esac
    shift
  done

  # Preprocessing
  local preprocessed=$(echo "$csvline" | tr -c '\\,"' ' ' | sed 's/\\\"/  /g' | fold -w1 | grep -nv " ")
  
  # Check if there are any quotes, if not we can optimize and just replace , with \n
  if [ $(echo "$preprocessed" | grep '"' | wc -l) -eq 0 ]; then
    if [ $numbered -eq 1 ]; then
      echo "$csvline" | tr ',' '\n' | nl -s':'
    else
      echo "$csvline" | tr ',' '\n'
    fi
    return 0
  fi

  # Initialize state variables
  local state="FIELD"
  local field_starts_index=1
  local field_end_index=0
  local field_number=1

  # Loop through preprocessed input
  for entry in $preprocessed; do
    index=$(echo "$entry" | cut -d':' -f1)
    char=$(echo "$entry" | cut -d':' -f2)
  
    case $state in
      FIELD)
        if [ "$char" == '"' ]; then
          state="QUOTES"
        elif [ "$char" == ',' ]; then
          field_end_index=$(expr $index - 1)
          field=$(echo "$csvline" | cut -c${field_starts_index}-${field_end_index})
          if [ $numbered -eq 1 ]; then
            echo "$field_number:$field"
          else
            echo "$field"
          fi
          field_starts_index=$(expr $index + 1)
          field_number=$(expr $field_number + 1)
        fi
        ;;
    
      QUOTES)
        if [ "$char" == '"' ]; then
          state="FIELD"
        fi
        ;;
    esac
  done

  # Print the last field if there's any content left
  field=$(echo "$csvline" | cut -c${field_starts_index}-)
  if [ $numbered -eq 1 ]; then
    echo "$field_number:$field"
  else
    echo "$field"
  fi

  return 0
}



#DOC: csvGetFieldIndex FIELDNAME FILE
#DOC:   NAME
#DOC:        csvGetFieldIndex - get the index (starting from 1) of a field with a given name (in the header)
#DOC:   SYNOPSIS
#DOC:        csvGetFieldIndex [av] [-o offsetIndex] FIELDNAME FILE
#DOC:   DESCRIPTION
#DOC:        csvGetFieldIndex gets the index (starting from 1) of the field with the given FIELDNAME in the header of the FILE.
#DOC:        Function is featuring grep hence you can use basic regex to search for fields 
#DOC:        Optional switches:
#DOC:        -a for printing all matching field indexes
#DOC:        -v for verbose output without cutting the index part
#DOC:        -o specifying an optional offset (starting index) to start search from, indexed from 1, offset also suport negative indexing (indexing from endof the array)
#DOC:   EXAMPLE
#DOC:        myCsvFile.csv have header as below
#DOC:        id,UserName,phone:work,phone:personal,email,gender
#DOC:        
#DOC:        csvGetFieldIndex UserName myCsvFile.csv
#DOC:        2
#DOC:  
#DOC:        csvGetFieldIndex phone myCsvFile.csv
#DOC:        3
#DOC:  
#DOC:        csvGetFieldIndex -o 4 phone myCsvFile.csv
#DOC:        4
#DOC: 
#DOC:        csvGetFieldIndex -a phone myCsvFile.csv
#DOC:        3
#DOC:        4
#DOC:  
#DOC:        csvGetFieldIndex -a -v phone myCsvFile.csv
#DOC:        3:phone:work
#DOC:        4:phone:personal
#DOC:  
#DOC:        csvGetFieldIndex -o -5 phone myCsvFile.csv #Don't print anything there is no phone field 5 filed from end
#DOC:   
#DOC:        csvGetFieldIndex -a -v -o -2 phone myCsvFile.csv
#DOC:        3:phone:work
#DOC:        4:phone:personal    
#DOC:  
#DOC:   EXIT STATUS
#DOC:        0 if the index is successfully found and printed
#DOC:        1 if the field name is not found in the header
#DOC:        10 if the number of arguments is incorrect
#DOC:        11 if the file does not exist
#DOC:        12 if the file is not readable
#DOC:        21 offset is not possitive number
#DOC:        22 offset is higher then total number of fields
#DOC: 
csvGetFieldIndex() {
    local fieldname=""
    local filename=""
    local offset=0  # Default value for the optional offset
    local all=0     # Flag for printing all matching indexes
    local verbose=0 # Flag for verbose output

    # Process arguments
    while [ "$1" != "" ]; do
        case $1 in
            -f | --fieldname )    shift
                                  fieldname=$1
                                  ;;
            -i | --inputfile )    shift
                                  filename=$1
                                  ;;
            -o | --offset )       shift
                                  offset=$1
                                  ;;
            -a | --all )          all=1
                                  ;;
            -v | --verbose )      verbose=1
                                  ;;
            --help )              echo "Usage: csvGetFieldIndex [av] [-o offsetIndex] FIELDNAME FILE" >&2
                                  exit 0
                                  ;;
            * )
                if [ -z "$fieldname" ]; then
                    fieldname=$1
                elif [ -z "$filename" ]; then
                    filename=$1
                else
                    echo "Usage: csvGetFieldIndex [av] [-o offsetIndex] FIELDNAME FILE" >&2
                    exit 1
                fi
        esac
        shift
    done

    # Precheck number of arguments
    if [ -z "$fieldname" ] || [ -z "$filename" ]; then
        echo "ERROR: incorrect arguments" >&2
        echo "Usage: csvGetFieldIndex [av] [-o offsetIndex] FIELDNAME FILE" >&2
        return 10
    fi

    # Precheck offset 
    if [ $(echo -n "$offset" |grep "^\-*[0-9]\+$" | wc -l) -eq 0 ]; then
        echo "ERROR: offset must be possitive number" >&2
        echo "Usage: csvGetFieldIndex [av] [-o offsetIndex] FIELDNAME FILE" >&2
        return 21
    fi

    # File existence and readability check
    csvCheckFile $filename
    local fcrv=$?

    if [ $fcrv -ne 0 ]; then
        return $fcrv
    fi

    # Use csvHeader2Index to get the header to index mapping
    local indexed_header
    indexed_header=$(csvHeader2Index "$filename")

    # Calculate the number of fields in the header
    local total_fields
    total_fields=$(echo "$indexed_header" | wc -l)

    #To support negative indexes, example like -2 is second from end
    if [ $offset -lt 0 ]; then
        #we revert the list 
        indexed_header=$(csvHeader2Index "$filename"|sort -nr)
        #and remove minus from offset
        offset=$(echo -n "$offset"|cut -c2-)
        #from now on it's just normal search with offset
    fi

    #Check if offset is not bigger then number of fields
    if [ $offset -gt $total_fields ]; then
        echo "ERROR: offset cannot be than bigger number of fields, number of fields in header: $total_fields" >&2
        echo "Usage: csvGetFieldIndex [av] [-o offsetIndex] FIELDNAME FILE" >&2
        return 22
    fi
    
    # Calculate the starting line considering the offset
    local starting_line
    if [ $offset -gt 1 ]; then
        starting_line=$(expr $total_fields - $offset)
        starting_line=$(expr $starting_line + 1)
    else
        starting_line=$total_fields
    fi

    # Limit output based on the starting line
    local filtered_header
    filtered_header=$(echo "$indexed_header" | tail -n $starting_line)

    # Find the field index/indices
    local result
    if [ $all -eq 1 ]; then
        if [ $verbose -eq 1 ]; then
            result=$(echo "$filtered_header" | grep "$fieldname")
        else
            result=$(echo "$filtered_header" | grep "$fieldname" | cut -d: -f1)
        fi
    else
        if [ $verbose -eq 1 ]; then
            result=$(echo "$filtered_header" | grep "$fieldname" | head -n 1)
        else
            result=$(echo "$filtered_header" | grep "$fieldname" | head -n 1 | cut -d: -f1)
        fi
    fi

    if [ -n "$result" ]; then
        # Output the result
        echo "$result"
        return 0
    else
        return 1
    fi
}

#DOC: csvHeader2Index FILE
#DOC:   NAME
#DOC:        csvHeader2Index - get the index mapping of each header field in a CSV file
#DOC:   SYNOPSIS
#DOC:        csvHeader2Index FILE
#DOC:   DESCRIPTION
#DOC:        csvHeader2Index gets the index (starting from 1) of each field in the header of the FILE and prints them along with the field names. If the file does not exist or is not readable, the function will return an error message and a non-zero exit code.
#DOC:   EXAMPLE
#DOC:        csvHeader2Index myCsvFile.csv
#DOC:        1:id
#DOC:        2:UserName
#DOC:        3:phone
#DOC:   EXIT STATUS
#DOC:        0 if the indices are successfully found and printed
#DOC:        10 if the number of arguments is incorrect
#DOC:        11 if the file does not exist
#DOC:        12 if the file is not readable
#DOC: 
csvHeader2Index() {
    local filename=""

    # Process arguments
    while [ "$1" != "" ]; do
        case $1 in
            -i | --inputfile )    shift
                                  filename=$1
                                  ;;
            --help )              csvHeader2Index_usage
                                  exit 0
                                  ;;
            * )
                if [ -z "$filename" ]; then
                    filename=$1
                else
                    echo "Usage: csvHeader2Index FILE" >&2
                    exit 1
                fi
        esac
        shift
    done

    # Precheck number of arguments
    if [ -z "$filename" ]; then
        echo "ERROR: incorrect arguments" >&2
        echo "Usage: csvHeader2Index FILE" >&2
        return 10
    fi

    # File existence and readability check
    csvCheckFile $filename
    local fcrv=$?

    if [ $fcrv -ne 0 ]; then
        return $fcrv
    fi

    # Read the header line once and transform commas to newlines
    local header
    header=$(head -n 1 "$filename" | tr ',' '\n')

    # Print each header field with its corresponding index
    local index=1
    while IFS= read -r line; do
        echo "$index:$line"
        index=$(expr $index + 1)
    done <<< "$header"
}

#DOC: csvAppend - append CSV data from one file to another
#DOC:
#DOC:   NAME
#DOC:       csvAppend - appends records from a source CSV to a target CSV
#DOC:
#DOC:   SYNOPSIS
#DOC:       csvAppend [-s|--strict] [-n|--dry-run] <source_file> <target_file>
#DOC:
#DOC:   DESCRIPTION
#DOC:       Validates headers between source and target CSVs (ignoring quotes),
#DOC:       and appends all non-header rows from source to target.
#DOC:       If --strict is provided, it additionally verifies:
#DOC:         - that each file has uniform field counts across all rows
#DOC:         - that the field count matches between source and target
#DOC:       If --dry-run is provided, the function prints the rows to stdout
#DOC:       instead of modifying the target file.
#DOC:
#DOC:   OPTIONS
#DOC:       -s, --strict     Enable structural validation
#DOC:       -n, --dry-run    Print rows to be appended instead of writing
#DOC:
#DOC:   RETURNS
#DOC:       0   on success
#DOC:       1   if source file does not exist
#DOC:       2   if source file is not readable
#DOC:       3   if target file does not exist
#DOC:       4   if target file is not writable (unless dry-run)
#DOC:       5   if headers differ after normalization
#DOC:       6   if source fails structural validation in strict mode
#DOC:       7   if target fails structural validation in strict mode
#DOC:       8   if source and target field counts differ in strict mode
#DOC:      98   if required arguments are missing
#DOC:      99   for unexpected arguments
#DOC:
#DOC:   EXAMPLES
#DOC:       csvAppend data.csv master.csv
#DOC:       csvAppend --strict updates.csv data.csv
#DOC:       csvAppend -sn new.csv report.csv
#DOC: 
csvAppend() {
  local strict_mode=0
  local dry_run=0
  local source_file target_file

  # Parse arguments
  while [[ "$1" ]]; do
    case "$1" in
      -s|--strict)
        strict_mode=1
        shift
        ;;
      -n|--dry-run)
        dry_run=1
        shift
        ;;
      *)
        if [[ -z "$source_file" ]]; then
          source_file="$1"
        elif [[ -z "$target_file" ]]; then
          target_file="$1"
        else
          echo "Unexpected argument: $1" >&2
          return 99
        fi
        shift
        ;;
    esac
  done

  # Validate args
  if [[ -z "$source_file" || -z "$target_file" ]]; then
    echo "Usage: csvAppend [-s|--strict] [-n|--dry-run] <source_file> <target_file>" >&2
    return 98
  fi

  # Source checks
  if [[ ! -f "$source_file" ]]; then
    echo "Source file '$source_file' does not exist." >&2
    return 1
  elif [[ ! -r "$source_file" ]]; then
    echo "Source file '$source_file' is not readable." >&2
    return 2
  fi

  # Target checks
  if [[ ! -f "$target_file" ]]; then
    echo "Target file '$target_file' does not exist." >&2
    return 3
  elif [[ "$dry_run" -eq 0 && ! -w "$target_file" ]]; then
    echo "Target file '$target_file' is not writable." >&2
    return 4
  fi

  # Normalize and compare headers
  local src_header tgt_header
  src_header=$(head -n 1 "$source_file" | sed 's/"//g')
  tgt_header=$(head -n 1 "$target_file" | sed 's/"//g')

  if [[ "$src_header" != "$tgt_header" ]]; then
    echo "Header mismatch (after quote normalization)—append aborted." >&2
    return 5
  fi

  # Structural validation
  if [[ "$strict_mode" -eq 1 ]]; then
    if ! csvCheckUniformFieldCount "$source_file"; then
      echo "Source file: $source_file has inconsistent field counts—append aborted." >&2
      return 6
    fi
    if ! csvCheckUniformFieldCount "$target_file"; then
      echo "Target file: $target_file has inconsistent field counts—append aborted." >&2
      return 7
    fi
    local src_fields tgt_fields
    src_fields=$(csvGetNumberOfFields "$source_file" | head -n 1)
    tgt_fields=$(csvGetNumberOfFields "$target_file" | head -n 1)
    if [[ "$src_fields" -ne "$tgt_fields" ]]; then
      echo "Field count mismatch between source and target—append aborted." >&2
      return 8
    fi
  fi

  # Append or simulate
  if [[ "$dry_run" -eq 1 ]]; then
    cat "$target_file"
    sed '1d' "$source_file"
  else
    sed '1d' "$source_file" >> "$target_file"
  fi
}

#DOC: csvPrepend - prepend CSV data from one file to another
#DOC:
#DOC:   NAME
#DOC:       csvPrepend - prepends records from a source CSV to a target CSV
#DOC:
#DOC:   SYNOPSIS
#DOC:       csvPrepend [-s|--strict] [-n|--dry-run] <source_file> <target_file>
#DOC:
#DOC:   DESCRIPTION
#DOC:       Validates headers between source and target CSVs (ignoring quotes),
#DOC:       and prepends all non-header rows from source to target just below the target's header.
#DOC:       If --strict is provided, it additionally verifies:
#DOC:         - that each file has uniform field counts across all rows
#DOC:         - that the field count matches between source and target
#DOC:       If --dry-run is provided, the function prints the resulting merged CSV to stdout
#DOC:       instead of modifying the target file.
#DOC:
#DOC:   OPTIONS
#DOC:       -s, --strict     Enable structural validation
#DOC:       -n, --dry-run    Simulate without writing, output result to stdout
#DOC:
#DOC:   RETURNS
#DOC:       0   on success
#DOC:       1-8 same codes and meanings as csvAppend
#DOC:      98   if required arguments are missing
#DOC:      99   for unexpected arguments
#DOC: 
csvPrepend() {
  local strict_mode=0
  local dry_run=0
  local source_file target_file

  # Parse flags
  while [[ "$1" ]]; do
    case "$1" in
      -s|--strict)
        strict_mode=1
        shift
        ;;
      -n|--dry-run)
        dry_run=1
        shift
        ;;
      *)
        if [[ -z "$source_file" ]]; then
          source_file="$1"
        elif [[ -z "$target_file" ]]; then
          target_file="$1"
        else
          echo "Unexpected argument: $1" >&2
          return 99
        fi
        shift
        ;;
    esac
  done

  if [[ -z "$source_file" || -z "$target_file" ]]; then
    echo "Usage: csvPrepend [-s|--strict] [-n|--dry-run] <source_file> <target_file>" >&2
    return 98
  fi

  if [[ ! -f "$source_file" ]]; then
    echo "Source file '$source_file' does not exist." >&2
    return 1
  elif [[ ! -r "$source_file" ]]; then
    echo "Source file '$source_file' is not readable." >&2
    return 2
  fi

  if [[ ! -f "$target_file" ]]; then
    echo "Target file '$target_file' does not exist." >&2
    return 3
  elif [[ "$dry_run" -eq 0 && ! -w "$target_file" ]]; then
    echo "Target file '$target_file' is not writable." >&2
    return 4
  fi

  local src_header tgt_header
  src_header=$(head -n 1 "$source_file" | sed 's/"//g')
  tgt_header=$(head -n 1 "$target_file" | sed 's/"//g')

  if [[ "$src_header" != "$tgt_header" ]]; then
    echo "Header mismatch (after quote normalization)—prepend aborted." >&2
    return 5
  fi

  if [[ "$strict_mode" -eq 1 ]]; then
    if ! csvCheckUniformFieldCount "$source_file"; then
      echo "Source file has inconsistent field counts—prepend aborted." >&2
      return 6
    fi
    if ! csvCheckUniformFieldCount "$target_file"; then
      echo "Target file has inconsistent field counts—prepend aborted." >&2
      return 7
    fi
    local src_fields tgt_fields
    src_fields=$(csvGetNumberOfFields "$source_file" | head -n 1)
    tgt_fields=$(csvGetNumberOfFields "$target_file" | head -n 1)
    if [[ "$src_fields" -ne "$tgt_fields" ]]; then
      echo "Field count mismatch between source and target—prepend aborted." >&2
      return 8
    fi
  fi

  if [[ "$dry_run" -eq 1 ]]; then
    echo "$tgt_header"
    sed '1d' "$source_file"
    sed '1d' "$target_file"
  else
    local tmp_file
    tmp_file=$(mktemp)
    {
      echo "$tgt_header"
      sed '1d' "$source_file"
      sed '1d' "$target_file"
    } > "$tmp_file"
    mv "$tmp_file" "$target_file"
    echo "Prepended records from '$source_file' to '$target_file'."
  fi
}

#DOC: csvFilterByField FIELD VALUE FILE
#DOC:   NAME
#DOC:        csvFilterByField - print out the lines where a field contains a specific value from a file
#DOC:   SYNOPSIS
#DOC:        csvFilterByField FIELD VALUE FILE
#DOC:   DESCRIPTION
#DOC:        csvFilterByField prints out the lines from the FILE where the FIELD contains the specific VALUE. If the file does not exist or is not readable, or if the number of arguments is incorrect, the function will return an error message and a non-zero exit code.
#DOC:   EXAMPLE
#DOC:        having file below I want to get list of Search Heads (Install_role = SH)
#DOC:        ID,Hostname,Role,IP,Install_role,Splunk_user,DataCollectors,,CPUs,RAM,Disk:/opt/splunk,Disk:/opt/data
#DOC:        1,baseImage,baseImage,127.0.0.1,,,,,,,,
#DOC:        2,TestSplunk,Development,10.0.0.101,SAD,splunk,infra360snmp-traps:tenant01,,2,8,100,200
#DOC:        3,labSH01,Search Head,10.0.0.102,SH,splunk,,,,,,
#DOC:        4,labSH02,Search Head,10.0.0.103,SH,splunk,,,,,,
#DOC:        5,labIDX01,Indexer,10.0.0.104,I,splunk,,,,,,
#DOC:        6,labIDX02,Indexer,10.0.0.105,I,splunk,,,,,, 
#DOC: 
#DOC:        [splunk@testSplunk tmp]$ csvFilterByField Install_role SH ACMESplunkClusterEnvironment.csv
#DOC:        3,labSH01,Search Head,10.0.0.102,SH,splunk,,,,,,
#DOC:        4,labSH02,Search Head,10.0.0.103,SH,splunk,,,,,,
#DOC:   EXIT STATUS
#DOC:        0 if the lines are successfully printed
#DOC:        10 if the number of arguments is incorrect
#DOC:        11 if the file does not exist
#DOC:        12 if the file is not readable
#DOC: 
csvFilterByField() {
  local fieldname=$1
  local fieldvalue=$2
  local filename=$3

  #precheck number of argunents
  if [ $# -gt 3 ]
  then
    echo 'incorrect arguments'
    return 10
  fi

  #file exist and is readable
  error_message=$(csvCheckFile $filename)
  fcrv=$?

  if [ $fcrv -ne 0 ]
  then
    echo $error_message
    #iniUsage iniGetAllSections
    return $fcrv
  fi

  local fieldname_index=$(csvGetFieldIndex $fieldname $filename)
  if [ $? -eq 1 ]
  then
    echo "No such field: $fieldname; in file: $filename" >&2
  fi

  while read LINE
  do
    if [ "$(echo $LINE | sed 's/\r//'| cut -d, -f$fieldname_index)" = "$fieldvalue" ]
    then
      echo $LINE
    fi
  done < $filename

}

#DOC: csvContainsMultiLinesFields
#DOC:   NAME
#DOC:     csvContainsMultiLinesFields - return the number of multi-line records in a given CSV file
#DOC:   SYNOPSIS
#DOC:     csvContainsMultiLinesFields [-v|-vv] FILE
#DOC:   DESCRIPTION
#DOC:     This function returns the number of multi-line records in a given CSV file.
#DOC:     A multi-line field in a CSV file is a field that contains line breaks.
#DOC:     Normally, each line in a CSV file represents a single record, with fields separated by a delimiter such as a comma.
#DOC:     However, sometimes a field may contain line breaks, which means that the record spans multiple lines in the file.
#DOC:     This can happen when a field contains text with paragraphs or other formatting that includes line breaks.
#DOC:
#DOC:     Options:
#DOC:       -v    Verbose output. Prints the filename and the number of the line where a multiline field is found.
#DOC:       -vv   More verbose output. Prints the filename, the number of the line, and the content of the line where a multiline field is found.
#DOC:
#DOC:   EXAMPLES
#DOC:     Here is an example of a CSV file that includes both normal (ID 1) and multi-line (ID 2) records:
#DOC:         ID,First Name,Last Name,Address,Phone
#DOC:         1,Jane,Doe,456 Elm St. Anytown, USA,555-1234
#DOC:         2,John,Doe,"123 Main St.
#DOC:         Anytown, USA",555-5678
#DOC:
#DOC:   Example of use:
#DOC: 
#DOC:         if csvContainsMultiLinesFields example.csv
#DOC:         then
#DOC:           echo "The file example.csv does not contain multi-line record
#DOC:         else
#DOC:           echo "The file example.csv does contain multi-line records"
#DOC:         fi
#DOC: 
#DOC:         Or as oneliner:
#DOC:         csv=example.csv; if csvContainsMultiLinesFields $csv; then echo "Not contain multi-line record; else echo "Contain multi-line records"; fi
#DOC: 
csvContainsMultiLinesFields() {
  local verbose=0
  while [ "$#" -gt 0 ]; do
    case "$1" in
      -v) verbose=1; shift ;;
      -vv) verbose=2; shift ;;
      *) file="$1"; shift ;;
    esac
  done
  
  if [ -z "$file" ]
  then
    echo "Error: No CSV file provided" >&2
    echo "Usage: csvContainsMultiLinesFields [-v|-vv] FILE" >&2
    return 1
  fi
  
  local csv=$file
  
  if [ ! -e "$csv" ]
  then
    echo "Error: File $csv does not exist" >&2
    echo "Usage: csvContainsMultiLinesFields [-v|-vv] FILE" >&2
    return 1
  fi
  
  if [ ! -r "$csv" ]
  then
    echo "Error: File $csv is not readable" >&2
    echo "Usage: csvContainsMultiLinesFields [-v|-vv] FILE" >&2
    return 1
  fi
  
  local backupIFS=$IFS
  local count=0
  IFS=$'\n'
  
  #get all lines which contains qoutes
  
  for line in $(grep -H -n -E '\"' $csv)
  do
    #get just the qutes (") and check if it even number modulo 2 = 1 (even number)
    if [ $(expr $(echo $line |tr -cd '\"' | wc -c) % 2) -eq 1 ]
    then
      count=$(expr $count + 1)
      if [ $verbose -eq 1 ]; then
        echo "filename: $csv, number of line: $(echo $line | cut -d ':' -f2)"
      elif [ $verbose -eq 2 ]; then
        echo "filename: $csv, number of line: $(echo $line | cut -d ':' -f2)"
        echo "line content: $(echo $line | cut -d ':' -f3-)"
      fi
    fi
  done
  
  IFS=$backupIFS
  
  return $count
}

#DOC: csvFlattenMultiLineFields [-s SEPARATOR] FILE
#DOC:   NAME
#DOC:        csvFlattenMultiLineFields - flatten multiline fields in a CSV file
#DOC:   SYNOPSIS
#DOC:        csvFlattenMultiLineFields [-s SEPARATOR] FILE
#DOC:   DESCRIPTION
#DOC:        csvFlattenMultiLineFields reads the content of the FILE given as an argument and flattens any multiline fields by removing newlines. An optional SEPARATOR can be specified using the -s flag, which will be inserted in place of the removed newlines. If the file does not exist or is not readable, the function will return an error message and a non-zero exit code.
#DOC:   OPTIONS
#DOC:        -s SEPARATOR
#DOC:             Specifies a separator to insert in place of removed newlines.
#DOC:   EXIT STATUS
#DOC:        0 if the content is successfully printed
#DOC:        1 if no parameter is entered
#DOC:        2 if the file doesn't exist
#DOC:        3 if the file is not readable
#DOC: 
csvFlattenMultiLineFields() {
    local separator=""
    local file=""
    while [ "$#" -gt 0 ]; do
        case "$1" in
            -s) separator="$2"; shift 2 ;;
            --) shift; break ;;
            *) file="$1"; shift ;;
        esac
    done

    if [ -z "$file" ]; then
        echo "Error: No parameter entered"
        echo "Usage: csvFlattenMultiLineFields [-s SEPARATOR] FILE"
        return 1
    elif [ ! -f "$file" ]; then
        echo "Error: File doesn't exist"
        echo "Usage: csvFlattenMultiLineFields [-s SEPARATOR] FILE"
        return 2
    elif [ ! -r "$file" ]; then
        echo "Error: Cannot read file"
        echo "Usage: csvFlattenMultiLineFields [-s SEPARATOR] FILE"
        return 3
    fi

    local linetoprint=""
    local line
    local quotes=0
    while IFS= read -r line || [ -n "$line" ]; do
        linetoprint="$linetoprint$line"
        quotes=$(echo "$linetoprint" | grep -o '"' | wc -l)
        if [ $(expr $quotes % 2) -eq 0 ]; then
            printf "%s\n" "$linetoprint"
            linetoprint=""
        else
            linetoprint="$linetoprint$separator"
        fi        
    done < "$file"
    if [ -n "$linetoprint" ]; then
        printf "%s\n" "$linetoprint"
    fi
}

#VERSION HISTORY:
#20221130,CORRECTED: csvGetFieldIndex and csvFilterByField; didn't work for last field with windows end of the line (correction remove WinOEL)
#20230419,ADDED: #DOC comments
#20230425,ADDED: Addition DOC Comments to support help system
#20230530,UPDATED: converted DOC Comments to linux man like style and make them more detail and descriptive to extend help system
#20230605,UPDATED: function definitions removed space between functionName and () to support the help system
#20230613,ADDED: containsMultiLinesFields
#20230622,ADDED: getCsveditVersion
#20230627,CORRECTED: csvCheckFile was reffering iniUsage, redirect the error message to stderr, Proper Usage for csvGetContent,containsMultiLinesFields,csvGetHeader
#20230716,ADDED: csvFlattenMultiLineFields, CHANGED: containsMultiLinesFields to csvContainsMultiLinesFields
#20230722,UPDATED: function csvContainsMultiLinesFields add verbose and more verbose mode
#20231016,CORRECTED: csvContainsMultiLinesFields help corrected
#20250209,UPDATED: csvGetFieldIndex - added options -a -v -o (all,verbose,offset) and used grep instaed of simple equal;ADDED: csvHeader2Index which print fields one pre lined with number, in forma line#:fieldName
#20250216,ADDED: csvLine2Fields - converts line to fields, one field per line
#20250530,ADDED: csvRemoveTrailingCommas alias, csvGetNumberOfFields function
#20250625,ADDED: csvCheckUniformFieldCount, csvAppend
#20250626,ADDED: csvPrepend