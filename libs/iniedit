#! /bin/sh

#Library to manipulate INI style config file from Command line
#This Library below contains its own documentation just do:
#grep "#DOC: " iniedit | sed 's/[ \t]*#DOC://'

# Library of functions to manipulate ini files
#Variables:
inieditAuthor='Jiri Kindl'
inieditVersion='20240603'

#Version history at the end of the file:

#DOC: LIBRARY NAME: iniedit
#DOC: DESCRIPTION: Library to manipulate INI style config file from Command line
#DOC: 

#LOAD LIBRARIES
LIBPATH="$(readlink -f "$0" | rev | cut -d'/' -f3- | rev)/libs"
if [ ! -e $LIBPATH/textEditAliases ]
then
  if [ -e ~/libs/textEditAliases ]    
  then
    . ~/libs/textEditAliases
  else
    . ../libs/textEditAliases
  fi 
else
  . "$LIBPATH/textEditAliases"
fi

#ENABLE OR DISABLE DEBUG
INIEDITDEBUG='FALSE'
#INIEDITDEBUG='TRUE'
INIEDITDEBUG_LOG="/tmp/iniedit_debug.log"

#DOC: getInieditVersion 
#DOC:   NAME 
#DOC:     getInieditVersion - Print iniedit version 
#DOC:   SYNOPSIS 
#DOC:     getInieditVersion
#DOC:   DESCRIPTION 
#DOC:     Print iniedit version, the version number is last changed date in format YYYYMMDD.
#DOC: 
getInieditVersion() {
  echo $inieditVersion
  return 0
}

printDebug() {
  now=$(date)
  message=$1
  if [ $INIEDITDEBUG = 'TRUE' ]
  then
    echo "$now;;$host;; DEBUG: $message" >> $INIEDITDEBUG_LOG
  fi
}

iniCheckFile() {
  local filename=$1
  if [ ! -e $filename ]
  then
    echo "File $filename do not exist"
    return 11
  fi

  if [ ! -r $filename ]
  then
    echo "File $filename not readable, Permission Denied"
    return 12
  fi
  return 0
}

#DOC: iniListSections
#DOC:   NAME
#DOC:     iniListSections - Print out all sections from an INI file, optionally with line numbers
#DOC:   SYNOPSIS
#DOC:     iniListSections [-n] FILENAME
#DOC:   DESCRIPTION
#DOC:     This function prints out all sections from the specified INI file.
#DOC:     If the -n option is provided, it also prints the line numbers where each section is found.
#DOC:   OPTIONS
#DOC:     -n  Show line numbers with section names.
#DOC:   EXAMPLES
#DOC:     iniListSections myIniFile.ini
#DOC:     iniListSections -n myIniFile.ini # With line numbers
#DOC:
iniListSections() {
  local filename
  local show_line_numbers=false
  local fcrv
  local usage="iniListSections [-n] myIniFile.ini"
  
  # Check for -n option
  if [ "$1" = "-n" ]; then
    show_line_numbers=true
    shift # Remove the -n argument
  fi

  filename=$1

  #precheck number of arguments
  if [ $# -ne 1 ]; then
    echo "Error: incorrect number of arguments, arguments given: $@" >&2
    echo "Usage: $usage" >&2
    return 10
  fi

  #file exist and is readable
  error_message=$(iniCheckFile "$filename")
  fcrv=$?

  if [ $fcrv -ne 0 ]; then
    echo "Error: $error_message" >&2
    echo "Usage: $usage" >&2
    return $fcrv
  fi 
  
  #function code start
  if $show_line_numbers; then
    cat "$filename" | winEOL2linEOL | trimText | grep -n -E "^\[.*\]$" | tr -d '[]'
  else
    cat "$filename" | winEOL2linEOL | trimText | grep -E "^\[.*\]$" | tr -d '[]'
  fi
  
  return 0
}


#DOC: iniExistSection
#DOC:   NAME
#DOC:     iniExistSection - Check if a section exists in an INI file
#DOC:   SYNOPSIS
#DOC:     iniExistSection SECTION FILENAME
#DOC:   DESCRIPTION
#DOC:     This function checks if the specified section exists in the specified INI file.
#DOC:   EXAMPLES
#DOC:     iniExistSection mySection myIniFile.ini
#DOC: 
iniExistSection() {
  # Convert the section name to hexadecimal to avoid issues with special characters
  local hex_section=$(printf "[%s]" "$1" | xxd -pu | tr -d '\n')
  local filename=$2
  local fcrv
  local usage="iniExistSection mySection myIniFile.ini"
  
  #precheck number of arguments
  if [ $# -ne 2 ]
  then
    echo "Error: incorrect number of arguments, arguments given: $@" >&2
    echo "Usage: $usage" >&2
    return 10
  fi
  printDebug "iniExistSection:START"
  printDebug "iniExistSection:arguments given: $@"
  printDebug "iniExistSection:arguments:section: $1"
  printDebug "iniExistSection:arguments:filename: $filename"
  printDebug "iniExistSection:hex_section: $hex_section"
  # Check if the file exists and is readable
  error_message=$(iniCheckFile $filename)
  fcrv=$?

  if [ $fcrv -ne 0 ]
  then
    echo "Error: $error_message" >&2
    echo "Usage: $usage" >&2
    printDebug "iniExistSection:END"
    return $fcrv
  fi

  # Function code start
  # Convert each section name in the file to hexadecimal and compare it to the input section
  # This avoids issues with variable expansion and special characters in the section names
  printDebug "iniExistSection:END"
  return $(cat $filename |winEOL2linEOL|trimText | grep -E "^\[.*\]$" |xxd -pu| tr -d '\n'| grep -q "$hex_section")
}


#DOC: iniGetSectionContent
#DOC:   NAME
#DOC:     iniGetSectionContent - Print out a whole section from an INI file
#DOC:   SYNOPSIS
#DOC:     iniGetSectionContent SECTION FILENAME
#DOC:   DESCRIPTION
#DOC:     This function prints out the specified section from the specified INI file.
#DOC:   EXAMPLES
#DOC:     iniGetSectionContent mySection myIniFile.ini
#DOC: 
iniGetSectionContent() {
  local section=$1
  local section_hex=$(printf "[%s]" "$1" | xxd -pu| tr -d '\n')
  local filename=$2
  local in_Section=1 # by default we are not in section
  local fcrv
  local LINE
  local usage="iniGetSectionContent mySection myIniFile.ini"
  local tmpfile="/tmp/.tmp_iniedit_$(echo $filename|rev|cut -d'/' -f1|rev)_$(date +%s)"

  #precheck number of argunents
  if [ $# -ne 2 ]
  then
    echo "Error: incorrect number of arguments, arguments given: $@" >&2
    echo "Usage: $usage" >&2
    return 10
  fi
  
  printDebug "iniGetSectionContent:START"
  printDebug "iniGetSectionContent:arguments given: $@"
  printDebug "iniGetSectionContent:section:$section"

  #file exist and is readable
  error_message=$(iniCheckFile $filename)
  fcrv=$?

  if [ $fcrv -ne 0 ]
  then
    echo "Error: $error_message" >&2
    echo "Usage: $usage" >&2
    return $fcrv
  fi

  #function code start
  
  #swtich off the special char expantion as for example * because those chars can be part of the file
  set -o noglob
  
  if $(iniExistSection "$section" $filename)
  then
    printDebug "iniGetSectionContent:section:$section;exist in file $tmpfile"
    
    cat $filename|winEOL2linEOL | trimText | removeBlankLines > $tmpfile
    #First try optimized version using tail and head
    if [ $(iniListSections -n "$tmpfile" | grep -A 1 -E "^[0-9]+:$section$" | wc -l) -eq 2 ]
    then
      local start_line=$(iniListSections -n "$tmpfile" | grep -A 1 -E "^[0-9]+:$section$" | head -n 1 | cut -d: -f1)
      local end_line=$(iniListSections -n "$tmpfile" | grep -A 1 -E "^[0-9]+:$section$" | tail -n 1 | cut -d: -f1)
      local number_of_lines=$(expr $end_line - $start_line)
      head -n $(expr $end_line - 1) "$tmpfile" | tail -n $number_of_lines
      rm -f $tmpfile
      return 0
    fi
    
    #Test if that is 1 whic means it's last section
    if [ $(iniListSections -n "$tmpfile" | grep -A 1 -E "^[0-9]+:$section$" | wc -l) -eq 1 ]
    then
      local start_line=$(iniListSections -n "$tmpfile" | grep -A 1 -E "^[0-9]+:$section$" | head -n 1 | cut -d: -f1)
      local end_line=$(cat "$tmpfile" |wc -l)
      local number_of_lines=$(expr $end_line - $start_line )
      tail -n $(expr $number_of_lines + 1) "$tmpfile"
      rm -f $tmpfile
      return 0
    fi

    #sanitaze the input
    cat $filename|winEOL2linEOL | trimText | removeBlankLines | sed 's/\\/\\\\/g;'> $tmpfile

    #cat $filename|winEOL2linEOL | trimText | removeBlankLines | sed 's/[]\/$*.^[]/\\&/g'> $tmpfile
    while read LINE
    do
      printDebug "iniGetSectionContent:LINE:$LINE;section_hex:$section_hex;LINE_IN_HEX:$(printf "%s" "$LINE" | xxd -pu | tr -d '\n');in_Section:$in_Section" 
      # if not in section
      if [ $in_Section -eq 1 ]
      then
        # if we find match
        if [ "$(printf "%s" "$LINE" | xxd -pu | tr -d '\n')" = "$section_hex" ]
        then
          in_Section=0 # set in section to "true"
          printf "%s\n" "$LINE"
        fi
      else
        #we are in section and checking if we find begining of next section
        if $(printf "%s\n" "$LINE"| grep -q -E "^\[.*\]$")
        then
          # when we find next section we break (stop processing), because section shall be unique
          break
          #in_Section=1
          #continue
        fi
        printf "%s\n" "$LINE"
      fi
    done < $tmpfile
  else
    printDebug "iniGetSectionContent:section:$section;does NOT exist in file $tmpfile"
    return 21 #section not exist
  fi

  
  #swtich on the special char expantion 
  set +o noglob
  #clean up
  if [ "$INIEDITDEBUG" != 'TRUE' ]
  then
    rm -f $tmpfile
  fi
  printDebug "iniGetSectionContent:END"
}

#DOC: iniGetSectionKeyValue
#DOC:   NAME
#DOC:     iniGetSectionKeyValue - Print out the value of a key from a given section in an INI file
#DOC:   SYNOPSIS
#DOC:     iniGetSectionKeyValue SECTION KEY FILENAME
#DOC:   DESCRIPTION
#DOC:     This function prints out the value of the specified key from the specified section in the specified INI file.
#DOC:   EXAMPLES
#DOC:     iniGetSectionKeyValue mySection myKey myIniFile.ini
#DOC: 
iniGetSectionKeyValue() {
  local section=$1
  local key=$2
  local filename=$3
  local usage="iniGetSectionKeyValue mySection myKey myIniFile.ini"

  #precheck number of arguments
  if [ $# -ne 3 ]; then
    echo "Error: incorrect number of arguments, arguments given: $@" >&2
    echo "Usage: $usage" >&2
    return 10
  fi

  #file exist and is readable
  error_message=$(iniCheckFile $filename)
  fcrv=$?

  if [ $fcrv -ne 0 ]; then
    echo "Error: $error_message" >&2
    echo "Usage: $usage" >&2
    return $fcrv
  fi

  #function code start
  #local value=""
  local state="READING_KEY"
  local current_key=""
  local tmpfile=$(mktemp)

  # Write the output of iniGetSectionContent to the temporary file
  iniGetSectionContent "$section" "$filename" > "$tmpfile"

  #swtich off the special char expantion as for example * because those chars can be part of the file
  set -o noglob

  while IFS= read -r line || [ -n "$line" ]; do
    #echo "DEBUG: line: $line"
    #echo "DEBUG: state: $state"
    case $state in
      READING_KEY)
        current_key=$(echo "$line" | sed "s/[ \t]*=.*//")
        #echo "DEBUG: current_key: \'$current_key\'"
        if [ "$current_key" = "$key" ]; then
          current_value=$(echo "$line" | sed "s/^[^=]*=[ \t]*//")
          last_char=$(echo "$current_value" | rev |cut -c 1)
          if [ "$last_char" = "\\" ]; then
            state="READING_MULTILINE_VALUE"
            #current_value=$(echo "$current_value" | sed "s/\\\\$//")
            #echo $line
            echo $current_value
          else
            #value="$current_value"
            #echo $line
            echo $current_value
            break
          fi
        fi
        ;;
      READING_MULTILINE_VALUE)
        last_char=$(echo "$line" | rev |cut -c 1)
        if [ "$last_char" = "\\" ]; then
          #current_value="$current_value\n$(echo "$line" | sed "s/\\\\$//")"
          echo $line
        else
          #current_value="$current_value\n$line"
          #value="$current_value"
          echo $line
          break
        fi
        ;;
    esac
  done < "$tmpfile"

  # Remove the temporary file
  rm -f "$tmpfile"

  #swtich on the special char expantion 
  set +o noglob

}

#DOC: iniListSectionKeys
#DOC:   NAME
#DOC:     iniListSectionKeys - Print out all keys from a section of an INI file
#DOC:   SYNOPSIS
#DOC:     iniListSectionKeys SECTION FILENAME
#DOC:   DESCRIPTION
#DOC:     This function prints out all keys from the specified section of the specified INI file.
#DOC:     If the section or file does not exist or is not readable, an error message is printed and the function returns a non-zero exit code.
#DOC:   EXAMPLES
#DOC:     iniListSectionKeys mySection myIniFile.ini
#DOC: 
iniListSectionKeys() {
    local section=$1
    local filename=$2
    local line_continuation=0
    local fcrv
    local usage="iniListSectionKeys mySection myIniFile.ini"

    #precheck number of argunents
    if [ $# -ne 2 ]
    then
      echo "Error: incorrect number of arguments, arguments given: $@" >&2
      echo "Usage: $usage" >&2
      return 10
    fi

    #file exist and is readable
    error_message=$(iniCheckFile $filename)
    fcrv=$?

    if [ $fcrv -ne 0 ]
    then
      echo "Error: $error_message" >&2
      echo "Usage: $usage" >&2
      return $fcrv
    fi
    
    local tmpfile=$(mktemp)
    # Write the output of iniGetSectionContent to the temporary file
    iniGetSectionContent "$section" "$filename" > "$tmpfile"

    while IFS= read -r line; do
        #echo "line_continuation: $line_continuation"
        #echo "line: $line"
        if [ $line_continuation -eq 0 ]; then
            if [ $(echo "$line" |  sed -n -E '/^[ \t]*[^= \t]+[ \t]*=/p' | wc -c) -gt 0 ]
            then
                #echo "line with key"
                key=$(echo "$line" | sed -n 's/^[ \t]*\([^= \t]\+\)[ \t]*=.*/\1/p')
                echo "$key"
                if echo "$line" | grep -q '\\[ \t]*$'; then
                    line_continuation=1
                fi
            fi
        else
            if ! echo "$line" | grep -q '\\[ \t]*$'; then
                line_continuation=0
            fi
        fi
    done < "$tmpfile"

    # Remove the temporary file
    rm -f "$tmpfile"
}

#DOC: iniExistSectionKey
#DOC:   NAME
#DOC:     iniExistSectionKey - Check if a given section and key exist in an INI file
#DOC:   SYNOPSIS
#DOC:     iniExistSectionKey SECTION KEY FILENAME
#DOC:   DESCRIPTION
#DOC:     This function returns true if the specified section and key exist in the specified INI file.
#DOC:   EXAMPLES
#DOC:     iniExistSectionKey mySection myKey myIniFile.ini
#DOC: 
iniExistSectionKey() {
  local section=$1
  local key=$2
  local filename=$3	
  local retval=1
  local usage="iniExistSectionKey mySection myKey myInifile.ini"
  #precheck number of argunents
    if [ $# -ne 3 ]
  then
    echo "Error: incorrect number of arguments, arguments given: $@" >&2
    echo "Usage: $usage" >&2
    return 10
  fi

  #file exist and is readable
  error_message=$(iniCheckFile $filename)
  fcrv=$?

  if [ $fcrv -ne 0 ]
  then
    echo "Error: $error_message" >&2
    echo "Usage: $usage" >&2
    return $fcrv
  fi
  
  #function code start here
  if [ $(iniGetSectionKeyValue $section $key $filename |wc -l) -gt 0 ]
  then
    retval=0
  fi

  return $retval
}

#DOC: iniRemoveSection
#DOC:   NAME
#DOC:     iniRemoveSection - Print out an INI file without a specific section
#DOC:   SYNOPSIS
#DOC:     iniRemoveSection SECTION FILENAME
#DOC:   DESCRIPTION
#DOC:     This function prints out the specified INI file without the specified section and all keys under that section.
#DOC:   EXAMPLES
#DOC:     iniRemoveSection mySection myIniFile.ini
#DOC: 
iniRemoveSection() {
  local section=$1
  local filename=$2
  local in_Section=1
  local LINE
  local usage="iniRemoveSection mySection myInifile.ini"
  local tmpfile="/tmp/.tmp_iniedit_$(echo $filename|rev|cut -d'/' -f1|rev)_$(date +%s)"

  #precheck number of argunents
  if [ $# -ne 2 ]
  then
    echo "Error: incorrect number of arguments, arguments given: $@" >&2
    echo $usage >&2
    return 10
  fi

  #file exist and is readable
  error_message=$(iniCheckFile $filename)
  fcrv=$?

  if [ $fcrv -ne 0 ]
  then
    echo "Error: $error_message" >&2
    echo "Usage: $usage" >&2
    return $fcrv
  fi

  #function code start
  
  cat $filename |winEOL2linEOL| trimText|sed 's/\\/\\\\/g;' > $tmpfile
  
  #swtich off the special char expantion as for example * because those chars can be part of the file
  set -o noglob
  
  if $(iniExistSection $section $tmpfile)
  then
    while read LINE
    do 
      if [ $in_Section -eq 1 ]
      then
        if $(echo $LINE | grep -q -E "^\[$section\]$")
        then
          in_Section=0
        else
          echo $LINE
        fi
      else
        if $(echo $LINE | grep -q -E "^\[.*\]$")
        then
          in_Section=1
          echo $LINE
        fi
      fi
    done < $tmpfile
  fi
  
  #swtich off the special char expantion 
  set +o noglob
  
  rm -f $tmpfile
}

#DOC: iniRemoveSectionKey
#DOC:   NAME
#DOC:     iniRemoveSectionKey - Print out an INI file without a specific key under a specific section
#DOC:   SYNOPSIS
#DOC:     iniRemoveSectionKey SECTION KEY FILENAME
#DOC:   DESCRIPTION
#DOC:     This function prints out the specified INI file without the specified key under the specified section.
#DOC:   EXAMPLES
#DOC:     iniRemoveSectionKey mySection myKey myIniFile.ini
#DOC: 
iniRemoveSectionKey() {
  local section=$1
  local key=$2
  local filename=$3
  local in_Section=1
  local usage="iniRemoveSectionKey mySection myKey myInifile.ini"
  local LINE
  local tmpfile="/tmp/.tmp_iniedit_$(echo $filename|rev|cut -d'/' -f1|rev)_$(date +%s)"

  #precheck number of argunents
  if [ $# -ne 3 ]
  then
    echo "Error: incorrect number of arguments, arguments given: $@" >&2
    echo "Usage: $usage" >&2
    return 10
  fi

  #file exist and is readable
  error_message=$(iniCheckFile $filename)
  fcrv=$?

  if [ $fcrv -ne 0 ]
  then
    echo "Error: $error_message" >&2
    echo "Usage: $usage" >&2
    return $fcrv
  fi

  #function code start

  # Convert Windows EOL to Linux EOL, trim text and escape backslashes
  cat $filename|winEOL2linEOL | trimText > $tmpfile
  
  # Switch off the special char expansion as for example * because those chars can be part of the file
  set -o noglob
  
  # Check if Section exists
  if $(iniExistSection $section $tmpfile)
  then
    # Initialize multilinekey flag as 1 (false) because by default the key is not multiline
    local multilinekey=1
    while IFS= read -r LINE || [ -n "$LINE" ]
    do 
      # If we are not in the section
      if [ $in_Section -eq 1 ]
      then
        # If we encounter the section again, we are in the section
        if $(echo $LINE | grep -q -E "^\[$section\]$")
        then
          in_Section=0
          echo $LINE
        else
          echo $LINE
        fi
      else
        # If we encounter any section, we are not in the section
        if $(echo $LINE | grep -q -E "^\[.*\]$")
        then
          in_Section=1
          echo $LINE
          continue
        fi

        #if we find the key we not echo anything
        if $(echo $LINE | grep -q -E "$key[ \t]*=")
        then
          #and check if it is multiline value, have \ at the end of the line
          last_char=$(echo "$LINE" | rev |cut -c 1)
          if [ "$last_char" = "\\" ]
          then
            multilinekey=0
          fi
          continue
        else # we are in section but line not matching key so we shall print if it is not multivalue
          # If we are in multilinekey mode (true)
          if [ $multilinekey -eq 0 ]
          then
            # If the line does not end with a backslash, exit multilinekey mode (set to false)
            #if ! $(echo $LINE | grep -q -E ".*\\$")
            last_char=$(echo "$LINE" | rev |cut -c 1)
            if [ ! "$last_char" = "\\" ]
            then
              multilinekey=1
              continue
            fi
          else #we are not in multiline AND also not match key line so we print the line
            echo $LINE
          fi
        fi
      fi
    done < $tmpfile 
  fi
  
  # Switch on the special char expansion 
  set +o noglob
  
  # Remove the temporary file
  rm -f $tmpfile

}

#DOC: iniSetSectionKeyValue
#DOC:   NAME
#DOC:     iniSetSectionKeyValue - Print out an INI file where it changes or adds a specific key in a specific section
#DOC:   SYNOPSIS
#DOC:     iniSetSectionKeyValue SECTION KEY VALUE FILENAME
#DOC:   DESCRIPTION
#DOC:     This function prints out the specified INI file where it changes or adds the specified key with the specified value in the specified section.
#DOC:   EXAMPLES
#DOC:     iniSetSectionKeyValue mySection myKey myValue myIniFile.ini
#DOC: 
iniSetSectionKeyValue() {
  #input ARGS
  local section=$1
  local section_hex=$(printf "[%s]" "$1" | xxd -pu| tr -d '\n')
  local key=$2
  local value=$3
  local filename=$4
  local usage="iniSetSectionKeyValue mySection myKey myValue myInifile.ini"
  local LINE
  local SSKV_STATUS='INIT'
  local tmpfile="/tmp/.tmp_iniedit_$(echo $filename|rev|cut -d'/' -f1|rev)_$(date +%s)"

  #precheck number of argunents
  if [ $# -ne 4 ]
  then
    echo "Error: incorrect number of arguments, arguments given: $@" >&2
    echo "Usage: $usage" >&2
    return 10
  fi

  #file exist and is readable
  error_message=$(iniCheckFile $filename)
  fcrv=$?

  if [ $fcrv -ne 0 ]
  then
    echo "Error: $error_message" >&2
    echo "Usage: $usage" >&2
    return $fcrv
  fi

  #function code start
  
  cat $filename |winEOL2linEOL| trimText|sed 's/\\/\\\\/g;' > $tmpfile
  
  #swtich off the special char expantion as for example * because those chars can be part of the file
  set -o noglob
  
  #Check if Section exist
  if $(iniExistSection $section $tmpfile)
  then
    #If Section Exist check if key Exist 
    if $(iniExistSectionKey $section $key $tmpfile)
    then
      # Start reading the file line by line
      while read LINE
      do 
        # Depending on the current state, perform different actions
        case $SSKV_STATUS in
          "INIT")
            # If we are in the INIT state and find the section we are looking for,
            # we switch to the INSECTION state and print the line
            #if $(echo $LINE | grep -q -E "^\[$section\]$")
            if [ "$(printf "%s" "$LINE" | xxd -pu | tr -d '\n')" = "$section_hex" ]
            then
              SSKV_STATUS="INSECTION"
              echo $LINE
              continue
            fi
            echo $LINE
            ;;
          "INSECTION")
            # If we are in the INSECTION state and find any section header,
            # we switch back to the INIT state and print the line
            if $(echo $LINE | grep -q -E "^\[.*\]$")
            then
              SSKV_STATUS="INIT"
              echo $LINE
              continue
            fi
            # If we find the key we are looking for, we check if it's a multiline value
            if $(echo $LINE| grep -q -E "$key[ \t]*=")
            then
              last_char=$(echo "$LINE" | rev |cut -c 1)
              # If the last character of the line is a backslash, it's a multiline value
              # We switch to the MULTILINEVALUE state and continue to the next line
              if [ "$last_char" = "\\" ]
              then
                SSKV_STATUS="MULTILINEVALUE"
                continue
              else
                # If it's not a multiline value, we print the updated key and value
                echo "$key = $value"
              fi
            else
              # If the line doesn't contain the key we are looking for, we print the line as is
              echo $LINE
            fi
            ;;
          "MULTILINEVALUE")
            # If we are in the MULTILINEVALUE state, we check if the current line is the last line of the multiline value
            last_char=$(echo "$LINE" | rev |cut -c 1)
            # If the last character of the line is not a backslash, it's the last line of the multiline value
            # We switch back to the INSECTION state and print the updated key and value
            if [ "$last_char" != "\\" ]
            then
              SSKV_STATUS="INSECTION"
              echo "$key = $value"
            fi
            ;;
        esac
      done < $tmpfile

      #swtich off the special char expantion 
      set +o noglob
    
    else
      #sed -e "/^\[$section\]$/ a $key = $value" $filename
      escaped_section=$(echo $section | sed -e 's/[]\/$*.^[]/\\&/g')
      sed -e "/^\[$escaped_section\]$/ a $key = $value" $filename
    fi
  else
  #If Section not exist, Append Section with new Key and Value
    cat $filename
    echo ""
    echo "[$section]"
    echo "$key = $value"
  fi

  rm -f $tmpfile
}

#DOC: iniFindValueKey 
#DOC:   NAME
#DOC:     iniFindValueKey - Print out all sections in which a combination of value and key is present
#DOC:   SYNOPSIS
#DOC:     iniFindValueKey KEY VALUE FILENAME
#DOC:   DESCRIPTION
#DOC:     This function prints out all sections in which the specified combination of value and key is present in the specified INI file.
#DOC:   EXAMPLES
#DOC:     iniFindValueKey myKey myValue myIniFile.ini
#DOC: 
iniFindValueKey() {
  local key=$1
  local value=$2
  local filename=$3
  local usage="iniFindValueKey myKey myValue myInifile.ini"
  local LINE
  local section
  local PREV_LINE=""
  local tmpfile="/tmp/.tmp_iniedit_$(echo $filename|rev|cut -d'/' -f1|rev)_$(date +%s)"
  local tmpfileFindValueKey="/tmp/.tmp_iniedit_FindValueKey_$(echo $filename|rev|cut -d'/' -f1|rev)_$(date +%s)"

  #precheck number of argunents
  if [ $# -ne 3 ]
  then
    echo "Error: incorrect number of arguments, arguments given: $@" >&2
    echo "Usage: $usage" >&2
    return 10
  fi

  #file exist and is readable
  error_message=$(iniCheckFile $filename)
  fcrv=$?

  if [ $fcrv -ne 0 ]
  then
    echo "Error: $error_message" >&2
    echo "Usage: $usage" >&2
  fi

  #function code start

  grep -E "$key[ \t]*=[ \t]*$value$|^\[.*\]$" $filename > $tmpfile
  while read LINE
  do
    if [ $(echo $LINE | grep "^\[.*\]$" |wc -l) -gt 0 ]
    then
      section=$LINE
    else
      echo $section >> $tmpfileFindValueKey
    fi
  done < $tmpfile

  cat $tmpfileFindValueKey | sort | uniq

  #clean up
  if [ $INIEDITDEBUG = 'FALSE' ]
  then
    rm -f $tmpfile
    rm -f $tmpfileFindValueKey
  fi
}

#DOC: iniSerialize
#DOC:   NAME
#DOC:     iniSerialize - Serialize an INI file into key-value pairs
#DOC:   SYNOPSIS
#DOC:     iniSerialize [-s separator] file
#DOC:   DESCRIPTION
#DOC:     This function takes an INI file as input and serializes its contents into key-value pairs in the format [section]:key=value.
#DOC:     The -s switch can be used to specify a separator for multiline values. If no -s switch is provided, the function will use a newline character (\n) as the default separator.
#DOC:     If the file argument is missing, the function prints an error message and a usage message to standard error and returns with a non-zero exit code to indicate an error.
#DOC:     If the specified file doesn't exist or isn't readable, the function prints an error message to standard error and returns with a non-zero exit code to indicate an error.
#DOC:     The following error return codes are used:
#DOC:       2 - Missing file argument
#DOC:       3 - File does not exist
#DOC:       4 - File is not readable
#DOC:   EXAMPLES
#DOC:     iniSerialize /path/to/config.ini
#DOC:     iniSerialize -s "SEPARATOR" /path/to/config.ini
#DOC: 
iniSerialize() {
    local separator='\n'
    local file=""
    while [ $# -gt 0 ]; do
        case "$1" in
            -s)
                separator="$2"
                shift 2
                ;;
            *)
                if [ -z "$file" ]; then
                    file="$1"
                    shift
                else
                    break
                fi
                ;;
        esac
    done

    if [ -z "$file" ]; then
        echo "Error: missing file argument" >&2
        echo "Usage: iniSerialize [-s separator] file" >&2
        return 2
    fi

    if [ ! -e "$file" ]; then
        echo "Error: file '$file' does not exist" >&2
        return 3
    fi

    if [ ! -r "$file" ]; then
        echo "Error: file '$file' is not readable" >&2
        return 4
    fi

    #remove empty lines
    local tmpfile=$(mktemp)
    sed '/^[ \t]*$/ d' $file > $tmpfile
    
    local section=""
    local key=""
    local value=""
    local state="KEY"
    while read -r line || [ -n "$line" ]; do
        printDebug "State=$state; Line=$line;"
        printDebug "Section=$section; Key=$key; Value=$value"
        case "$state" in
            KEY)
                case "$line" in
                    \[*\])
                        if [ -n "$value" ]; then
                            echo "[$section]:$key=$value"
                            value=""
                        fi
                        section=$(echo "$line" | tr -d '[]')
                        ;;
                    *=*)
                        if [ -n "$value" ]; then
                            echo "[$section]:$key=$value"
                            value=""
                        fi

                        key=$(echo "$line" | cut -d= -f1)
                        value=$(echo "$line" | cut -d= -f2-)
                        if echo "$value" | grep -q '\\$'; then # check if the value ends with a backslash 
                            state="VALUE"
                            value="$(echo "$value" | sed 's/\\$//')" # remove the trailing backslash from the value using sed 
                        else 
                            echo "[$section]:$key=$value"
                            value=""
                        fi 
                        ;;
                    *)  
                        echo $line #to preserve comments
                        ;;
                esac 
                ;;
            VALUE)
                case "$line" in 
                    *\\)
                        value="$value$separator$(echo "$line" | sed 's/\\$//')" # remove the trailing backslash from the line using sed and append it to the value 
                        ;;
                    *)
                        value="$value$separator$line"
                        state="KEY"
                        ;;
                esac 
                ;;
        esac 
    done < "$tmpfile"

    if [ -n "$value" ]; then # print the last key-value pair, if any 
        echo "[$section]:$key=$value"
    fi

    rm -f $tmpfile
    return 0 # success!
}

#DOC: iniUpdate
#DOC:   NAME
#DOC:     iniUpdate - Update an INI file with updates from another INI file
#DOC:   SYNOPSIS
#DOC:     iniUpdate FILE_TO_UPDATE FILE_WITH_UPDATES
#DOC:   DESCRIPTION
#DOC:     This function updates the specified INI file (FILE_TO_UPDATE) with updates from another specified INI file (FILE_WITH_UPDATES).
#DOC:     For each section in the FILE_WITH_UPDATES, it gets all keys and their values and updates the FILE_TO_UPDATE using the iniSetSectionKeyValue function.
#DOC:     If the correct number of arguments are not entered or if either of the files are not readable or if the FILE_TO_UPDATE is not writable, an error message is printed and the function returns a non-zero exit code.
#DOC:     The following error return codes are used:
#DOC:       1 - Invalid number of arguments
#DOC:       2 - FILE_TO_UPDATE does not exist
#DOC:       3 - FILE_TO_UPDATE is not readable
#DOC:       4 - FILE_TO_UPDATE is not writable
#DOC:       5 - FILE_WITH_UPDATES does not exist
#DOC:       6 - FILE_WITH_UPDATES is not readable
#DOC:   EXAMPLES
#DOC:     iniUpdate myIniFile.ini myUpdates.ini
#DOC: 
iniUpdate() {
  if [ "$#" -ne 2 ]; then
    echo "Error: incorrect number of arguments, arguments given: $@" >&2
    echo "Usage: iniUpdate FILE_TO_UPDATE FILE_WITH_UPDATES" >&2
    return 1
  fi

  local fileToUpdate="$1"
  local fileWithUpdates="$2"

  if [ ! -e "$fileToUpdate" ]; then
    echo "Error: $fileToUpdate does not exist." >&2
    echo "You can create an empty file by running the command: touch $fileToUpdate" >&2
    return 2
  fi

  if [ ! -r "$fileToUpdate" ]; then
    echo "Error: $fileToUpdate is not readable." >&2
    echo "You can try to fix this by running the command: chmod +r $fileToUpdate" >&2
    return 3
  fi

  if [ ! -w "$fileToUpdate" ]; then
    echo "Error: $fileToUpdate is not writable." >&2
    echo "You can try to fix this by running the command: chmod +w $fileToUpdate" >&2
    return 4
  fi

  if [ ! -e "$fileWithUpdates" ]; then
    echo "Error: $fileWithUpdates does not exist." >&2
    echo "Please check the file path and try again." >&2
    return 5
  fi

  if [ ! -r "$fileWithUpdates" ]; then
    echo "Error: $fileWithUpdates is not readable." >&2
    echo "You can try to fix this by running the command: chmod +r $fileWithUpdates" >&2
    return 6
  fi


  printDebug "iniUpdate:START"
  printDebug "iniUpdate:arguments given: $@"
  printDebug "iniUpdate:arguments:fileToUpdate:$fileToUpdate"
  printDebug "iniUpdate:arguments:fileWithUpdates:$fileWithUpdates"

  #seems that last line of $fileWithUpdates is omited so lets appand empty line as workaround
  echo >> $fileWithUpdates

  local tmpFile=$(mktemp)

  #local sections=$(iniListSections "$fileWithUpdates" |sed 's/\\/\\\\/g;'| sed 's/\$/\\\$/g' )
  local sections=$(iniListSections "$fileWithUpdates")

  for section in $sections; do
    printDebug "iniUpdate:section:$section"
    local keys=$(iniListSectionKeys "$section" "$fileWithUpdates")
    if $(iniExistSection "$section" "$fileToUpdate")
    then
      for key in $keys; do
        printDebug "iniUpdate:section:$section;key:$key"
        local value=$(iniGetSectionKeyValue "$section" "$key" "$fileWithUpdates")

        iniSetSectionKeyValue "$section" "$key" "$value" "$fileToUpdate" > "$tmpFile"
        cat "$tmpFile" > "$fileToUpdate"
      done
    else
      echo "" >> $fileToUpdate
      iniGetSectionContent "$section" "$fileWithUpdates" >> $fileToUpdate
    fi
  done
  
  if [ "$INIEDITDEBUG" != 'TRUE' ]
  then
    rm -f "$tmpFile"
  fi

  printDebug "iniUpdate:END"
}

#DOC: iniIdentifyUpdates
#DOC:   NAME
#DOC:     iniIdentifyUpdates - Identify updates in an INI file compared to another INI file
#DOC:   SYNOPSIS
#DOC:     iniIdentifyUpdates FILE_TO_COMPARE FILE_WITH_UPDATES
#DOC:   DESCRIPTION
#DOC:     This function identifies updates in the specified INI file (FILE_WITH_UPDATES) compared to another specified INI file (FILE_TO_COMPARE).
#DOC:     It prints out new sections, new keys in existing sections, and any keys whose values have changed.
#DOC:     If the correct number of arguments are not entered or if either of the files are not readable, an error message is printed and the function returns a non-zero exit code.
#DOC:     The following error return codes are used:
#DOC:       1 - Invalid number of arguments
#DOC:       2 - FILE_TO_COMPARE does not exist
#DOC:       3 - FILE_TO_COMPARE is not readable
#DOC:       4 - FILE_WITH_UPDATES does not exist
#DOC:       5 - FILE_WITH_UPDATES is not readable
#DOC:   OUTPUT
#DOC:     The output is a list of changes between the two INI files. Each change is prefixed by "Added:", "Changed:", "ChangedFrom:", or "ChangedTo:".
#DOC:     For example:
#DOC:       Added: [new_section]
#DOC:       Added: new_key = new_value
#DOC:       Changed: [existing_section]
#DOC:       Added: new_key = new_value
#DOC:       ChangedFrom: existing_key = old_value
#DOC:       ChangedTo: existing_key = new_value
#DOC:   EXAMPLES
#DOC:     iniIdentifyUpdates file1.ini file2.ini
#DOC: 
iniIdentifyUpdates() {
  if [ "$#" -ne 2 ]; then
    echo "Error: incorrect number of arguments, arguments given: $@" >&2
    echo "Usage: iniIdentifyUpdates FILE_TO_COMPARE FILE_WITH_UPDATES" >&2
    return 1
  fi

  local fileToCompare="$1"
  local fileWithUpdates="$2"

  if [ ! -e "$fileToCompare" ]; then
    echo "Error: $fileToCompare does not exist." >&2
    return 2
  fi

  if [ ! -r "$fileToCompare" ]; then
    echo "Error: $fileToCompare is not readable." >&2
    return 3
  fi

  if [ ! -e "$fileWithUpdates" ]; then
    echo "Error: $fileWithUpdates does not exist." >&2
    return 4
  fi

  if [ ! -r "$fileWithUpdates" ]; then
    echo "Error: $fileWithUpdates is not readable." >&2
    return 5
  fi

  # Get all sections from both files
  local sections1=$(iniListSections $fileToCompare)
  local sections2=$(iniListSections $fileWithUpdates)

  # Find sections in file2 that are not in file1
  local new_sections=$(echo "$sections2" | grep -vxF "$sections1")
  if [ -n "$new_sections" ]; then
    echo "$new_sections" | while read -r section; do
      echo "Added Section:     [$section]"
      local section_content=$(iniGetSectionContent "$section" $fileWithUpdates | sed '1 d')
      echo "$section_content" | while read -r line; do
        echo "Added:             $line"
      done
      echo ""
    done
  fi

    # Compare keys and values in sections present in both files
    local common_sections=$(echo "$sections1" | grep -xF "$sections2")
    echo "$common_sections" | while read -r section; do
    local keys1=$(iniListSectionKeys "$section" $fileToCompare)
    local keys2=$(iniListSectionKeys "$section" $fileWithUpdates)

    # Find new keys in file2
    local new_keys=$(echo "$keys2" | grep -vxF "$keys1")
    local common_keys=$(echo "$keys1" | grep -xF "$keys2")

    local sectionPrinted=0

    # Check if there are any new keys
    if [ -n "$new_keys" ]; then
      if [ "$sectionPrinted" -eq 0 ]; then
        echo "Changed Section:     [$section]"
        sectionPrinted=1
      fi
      echo "$new_keys" | while read -r key; do
        local value=$(iniGetSectionKeyValue "$section" $key $fileWithUpdates)
        echo "Added:               $key = $value"
      done
    fi   

    # Check if there are any common keys before comparing their values
    if [ -n "$common_keys" ]; then
      echo "$common_keys" | while read -r key; do
        local value1=$(iniGetSectionKeyValue "$section" $key $fileToCompare)
        local value2=$(iniGetSectionKeyValue "$section" $key $fileWithUpdates)
        if [ "$value1" != "$value2" ]; then
          if [ "$sectionPrinted" -eq 0 ]; then
            echo "Changed Section:     [$section]"
            sectionPrinted=1
          fi
          echo "ChangedFrom:         $key = $value1"
          echo "ChangedTo:           $key = $value2"
          if [ $(echo "$value1" | wc -l) -gt 1 ] || [ $(echo "$value1"|wc -l) -gt 1 ]
          then
            echo "DiffOutput:"
  
            # Create temporary files
            tempfile1=$(mktemp)
            tempfile2=$(mktemp)

            # Write the variable values to the temporary files
            echo "$value1" > "$tempfile1"
            echo "$value2" > "$tempfile2"

            # Perform the diff operation
            diff "$tempfile1" "$tempfile2"
          
            # Remove the temporary files
            rm "$tempfile1"
            rm "$tempfile2"
          fi
        fi
      done
    fi


    if [ "$sectionPrinted" -eq 1 ]; then
      echo ""
    fi
  done
}


#DOC: USAGE TIPS:
#DOC: 
#DOC:   USE CASE 1
#DOC:     I have config which contains multiple sections/stanzas for HPiLO and I want to remove them all
#DOC:     tmpfile=$(mktemp)
#DOC:     cp savedsearches.conf new_savedsearches.conf
#DOC:     newFile='new_savedsearches.conf'
#DOC:     for section in $(iniListSections $newFile | grep 't2_HPiLO-'); do echo "Removing $section"; iniRemoveSection $section $newFile > $tmpfile; cat $tmpfile > $newFile; done
#DOC:     rm $tmpfile
#DOC: 
#DOC:     similarly I can remove all sections which not contain cisco (grep -v 'cisco')
#DOC:     for section in $(iniListSections $newFile | grep -v 'cisco'); do echo "Removing $section"; iniRemoveSection $section $newFile > $tmpfile; cat $tmpfile > $newFile; done
#DOC: 
#DOC:   USE CASE 2
#DOC:     I want to sort sections/stanzas and print them and their content in alphabetical order
#DOC:     fileIWantSort='savedsearches.conf'
#DOC:     sortedFile='savedsearches_sorted.conf'
#DOC:     for section in $(iniListSections $fileIWantSort | sort); do iniGetSectionContent $section $fileIWantSort >> $sortedFile; echo "" >> $sortedFile; done
#DOC: 

#TODO: Make sure all functions have return code
#TODO: Documnet Return Codes in DOC: commnets789

#VERSION HISTORY:
#Version,Comment
#20210913,ADDED: functions removeSectionKey, removeSection
#20210915,ADDED: function nicerIni
#20210920,ADDED: the $LIBPATH to make sure library will load, correct tmpfile
#20220206,UPDATED: better the loading of dependencies (libs)
#20220215,ADDED: conversion of windows end of the lines to linux end of the lines 
#20220216,ADDED: correct \ handeling in all functions, in getSectionAllKeys added support for wildcards
#20221106,CHANGE: function renaming, better DOC comments
#20221107,ADDED iniUsage, better DOC comments
#20221110,ADDED: printDebug to be able do debuging, iniFindValueKey to find in which section combiantion of value and key exists
#20221111,ADDED: to all functions input number checking and file existenc and access checking, if check fails error message is print followed by usage
#20230420,ADDED: Addition DOC Comments to support help system
#20230527,UPDATED: converted DOC Comments to linux man like style and make them more detail and descriptive to extend help system
#20230601,CHANGED: iniGetAllSections renamed to iniListSections, iniGetSectionAllKeys renamed to iniGetSectionContent
#20230602,ADDED: iniListSectionKeys
#20230603,CORRECTED: iniGetSectionKeyValue
#20230604,CORRECTED: iniListSectionKeys and iniGetSectionKeyValue to be more POSIX compliant and avoid using process substitution by using tempfile
#20230605,UPDATED: function definitions removed space between functionName and () to support the help system
#20230615,ADDED: iniUpdate to make batch changes to ini file possible
#20230621,ADDED: example of use to remove more Sections at once based on naming
#20230622,ADDED: getInieditVersion, CHANGED: created USAGE TIPS: section of DOCs and moved the example of use to remove more Sections there
#20230629,UPDATED: USE CASE 1 make more reusable and added one more example
#20230803,UPDATED: iniUpdate - unique error codes, CHANGED: remove iniUsage and add separate usage to each function,
#20230810,ADDED: iniSerialize
#20240320,ADDED: iniIdentifyUpdates
#20240403,UPDATED: In all funtion changed the error message "Error: incorrect number of arguments, arguments given: $@" to show arguments entered.
#20240413,CORRECTED: iniSectionExist, iniGetSectionContent: work correctly with sections containing \ and $ 
#20240529,CORRECTED: iniRemoveSectionKey wasn't working for multiline vuales
#20240529,CORRECTED: iniSetSectionKeyValue wasn't working for multiline vuales
#20240618,UPDATED: iniListSections added -n option to give the line number of section, this allows further optimization in iniGetSectionContent
#20240619,UPDATED: iniGetSectionContent optimization using iniListSections -n and using line numbers to feature head and tail
#20240626,UPDATED: iniUpdate optimization using iniGetSectionContent for notexisting sections